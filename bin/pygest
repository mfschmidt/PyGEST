#!/usr/bin/env python3

""" pygest

    A command-line interface to the PyGEST library.

    commands:

        push : maximize the Mantel correlation between expression-similarity and a comparator matrix

            $ pygest push H03511009 L --minmax max
            $ pygest push H03511009 L --data /var/alt_data --samples cortical --approach exhaustive

        push : minimize the Mantel r-values between expression and a comparator matrix

            $ pygest push H03511009 L --minmax min

        order : order probes by their contribution to the r-value between expression-similarity and a comparator matrix

            $ pygest order H03511009 L --comparator dist

"""

import os
import sys
import argparse
import pkg_resources
import logging

import pygest as ge
from pygest.convenience import path_to
from pygest.cmdline import Split, Push, Move, Csv2df, Ktau, Status


def main():
    # PyGEST likes to manage its own threads since it knows how it's distributing them.
    if 'OPENBLAS_NUM_THREADS' not in os.environ:
        os.environ['OPENBLAS_NUM_THREADS'] = '1'

    # Collect commands and route them to the appropriate code.
    parser, arguments = parse_args()

    # data, logger = setup(arguments)
    # if arguments.verbose:
    #     report_context(arguments, logger)

    command = arguments.command.lower()
    if command == 'version':
        print("pygest v{}".format(pkg_resources.require("pygest")[0].version))
        return 0
    elif command == 'csv2df':
        return Csv2df(arguments.command_specific_arguments).run()
    elif command == 'ktau':
        return Ktau(arguments.command_specific_arguments).run()
    elif command == 'status':
        return Status(arguments.command_specific_arguments).run()
    elif command == 'split':
        return Split(arguments.command_specific_arguments).run()
    elif command == 'order':
        return Push(arguments.command_specific_arguments).do_order()
    elif command == 'push':
        return Push(arguments.command_specific_arguments).run()
    elif command == 'move':
        return Move(arguments.command_specific_arguments).run()
    else:
        print("I don't recognize the command, '{}'".format(command))


def parse_args():
    """ Grab the command and pass the rest along. """

    parser = argparse.ArgumentParser(description="PyGEST command-line interface")
    # Argparse can't seem to grab optional arguments from the end here, then avoid passing them along in
    # 'command_specific_arguments'. So all commands need to handle their own -v and --log and --data.
    # I can't think of a DRY way to handle this without a log of class overhead. But that's the next step.
    parser.add_argument("command",
                        help="What you would like PyGEST to do.")
    parser.add_argument("command_specific_arguments", nargs=argparse.REMAINDER,
                        help="further command-specific arguments")

    args = parser.parse_args()
    args.verbose = True

    if "data" not in args or args.data == "NONE":
        if "PYGEST_DATA" in os.environ:
            args.data = os.environ['PYGEST_DATA']
        else:
            print("I don't know where to find data. Try one of the following, with your own path:")
            print("")
            print("    $ pygest push {} --data /home/mike/ge_data".format(" ".join(sys.argv[1:])))
            print("")
            print("or, even better, set it in your environment (use ~/.bashrc as a permanent solution)")
            print("")
            print("    $ export PYGEST_DATA=/home/mike/ge_data")
            print("    $ pygest push {}".format(" ".join(sys.argv[1:])))
            print("")
            sys.exit(1)

    return parser, args


def setup(args):
    """ Create a logger and handlers, and use them while gaining access to ge.Data.

    :param args: command-line arguments
    :return: PyGEST::ExpressionData object, logger
    """

    # Set up logging, formatted with datetimes.
    log_formatter = logging.Formatter(fmt='%(asctime)s | %(message)s', datefmt='%Y-%m-%d_%H:%M:%S')
    logger = logging.getLogger('pygest')
    logger.setLevel(1)

    # Set up the console (stdout) log handler
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(log_formatter)
    console_handler.setLevel(logging.DEBUG if ("verbose" in args and args.verbose) else logging.INFO)
    logger.addHandler(console_handler)

    # Set up the file handler, if requested
    if "log" in args and args.log != '':
        file_handler = logging.FileHandler(args.log, mode='a+')
        file_handler.setFormatter(log_formatter)
        # file_handler.setLevel(logging.DEBUG if args.verbose else logging.INFO)
        # As a design decision, heavy logging to a file is almost always desirable, without clogging stdout
        file_handler.setLevel(logging.DEBUG)
        logger.addHandler(file_handler)
    else:
        file_handler = logging.FileHandler(
            path_to(args.command, args) + '.log',
            mode='a'
        )
        file_handler.setFormatter(log_formatter)
        file_handler.setLevel(logging.DEBUG)
        logger.addHandler(file_handler)

    if args.command in ['push', 'order', 'ktau', 'status', ]:
        data = ge.Data(args.data, logger)
    else:
        # args.command in ['version', 'csv2df'] which don't access data.
        data = None

    return data, logger


def report_context(args, logger):
    """ Report our interpretation of command-line arguments.

    :param args: Command line arguments
    :param logger: Logger object, output is sent here.
    """

    # print("Trying to report context to logger at level {}".format(logger.level))
    # for handler in logger.handlers:
    #     print("  logger {} has handler {} at level {}".format(logger.name, handler.name, handler.level))
    logger.info("--------------------------------------------------------------------------------")
    logger.info("  Command: {}".format(" ".join(sys.argv[:])))
    logger.info("  OPENBLAS_NUM_THREADS = {}".format(os.environ['OPENBLAS_NUM_THREADS']))
    try:
        logger.info("  PyGEST is running version {}".format(pkg_resources.require("pygest")[0].version))
    except pkg_resources.DistributionNotFound:
        logger.info("  PyGEST is running uninstalled; no version info is available.")
    logger.debug("    interpretation of arguments:")
    for k in args.__dict__:
        if args.__dict__[k] is not None:
            logger.debug("      - {} = {}".format(k, args.__dict__[k]))
    path_type = 'split' if args.command == 'split' else 'result'
    logger.info("   {} path:".format(path_type))
    logger.info("   '{}'".format(path_to(args.command, args, path_type=path_type)))
    logger.info("--------------------------------------------------------------------------------")


if __name__ == "__main__":
    sys.exit(main())
